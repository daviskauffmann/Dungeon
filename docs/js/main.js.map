{"version":3,"sources":["webpack:///webpack/bootstrap 1220b051d88ea2749cbc","webpack:///./src/ts/game.ts","webpack:///./src/ts/math.ts","webpack:///./src/ts/types.ts","webpack:///./src/ts/algorithms.ts","webpack:///./src/ts/utils.ts","webpack:///./src/ts/actors.ts","webpack:///./src/ts/generators.ts","webpack:///./src/ts/renderer.ts","webpack:///./src/ts/main.ts","webpack:///./src/ts/input.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC7D6B;AACP;AACG;AACc;AACnB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AAAA;AAAA;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB;;;;;;;;;;;;;AC5DR;AAC2B;AAC5C;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,uBAAuB,iBAAiB;AACxC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzHe;AACU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1E6B;AACD;AACS;AACC;AAC2B;AAC7C;AACpB;AACA,uEAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAAgC,WAAW,eAAe,YAAY;AACtE;AACA;AACA,+EAAgC,WAAW,SAAS,YAAY;AAChE;AACA;AACA,aAAa;AACb,2CAA2C,WAAW,4HAA4E;AAClI;AACA;AACA;AACA;AACA;AACA,2EAA4B,WAAW,UAAU,YAAY;AAC7D;AACA;AACA,2EAA4B,WAAW,qBAAqB,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAwB,WAAW,WAAW,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA4C,WAAW;AACvD;AACA;AACA;AACA,2FAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAoC,WAAW,QAAQ,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA4B,WAAW;AACvC;AACA;AACA;AACA,mFAAoC,WAAW,WAAW,gBAAgB;AAC1E;AACA;AACA;AACA,mFAAoC,WAAW;AAC/C;AACA;AACA;AACA,+EAAgC,WAAW;AAC3C;AACA;AACA;AACA,2EAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAwB,WAAW,YAAY,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAwB,WAAW,cAAc,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA4C,WAAW,sBAAsB,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAwC,WAAW,SAAS,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAwC;AACtE;AACA;AACA;AACA;AACA,+EAAgC,WAAW,SAAS,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;;;;;;;;;;;;;;;ACvTe;AACkB;AAC8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAA4C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D,sCAAsC,4BAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,4BAA4B;AAC3D,kCAAkC,4BAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5VsC;AAChB;AACK;AACR;AACF;AACG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+BAA+B,4BAA4B;AAC3D,kCAAkC,4BAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAA0B,2BAA2B;AACrD,2CAA2C,gCAAgC;AAC3E,8CAA8C,gCAAgC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD,8BAA8B,4BAA4B;AAC1D;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,kDAAkD,UAAU,yDAAyD,SAAS,yDAAU;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gFAA+B,IAAI,UAAU,EAAE,mCAAmC;AAC9G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C,8BAA8B,WAAW;AACzC;AACA;;;;;;;;;;;;;ACjMe;AACO;AACN;AACD;AACf;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPwE;AAClD;AAC4B;AACzB;AACV;AACY;AACP;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAwC,+BAA+B;AACvE;AACA;AACA;AACA,yFAAwC,+BAA+B;AACvE;AACA;AACA;AACA,yFAAwC,+BAA+B;AACvE;AACA;AACA;AACA,yFAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA6C,YAAY,SAAS,gDAAgD;AAClH;AACA;AACA,4FAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAyC,YAAY,YAAY,UAAU;AAC3E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAyC,YAAY,cAAc,UAAU;AAC7E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAyC,YAAY,aAAa,4FAA6C,YAAY,6FAA8C;AACzK;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"./docs/js/main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1220b051d88ea2749cbc","import { tick as actor_tick } from \"./actors\";\r\nimport { lineOfSight } from \"./algorithms\";\r\nimport { radiansBetween } from \"./math\";\r\nimport { Disposition, Faction, UIMode } from \"./types\";\r\nimport { findActor } from \"./utils\";\r\nexport const config = {\r\n    actorInfo: [\r\n        {\r\n            char: \"@\",\r\n            disposition: Disposition.Aggressive,\r\n            factions: [\r\n                Faction.Player,\r\n            ],\r\n            hostileFactions: [\r\n                Faction.Monster,\r\n            ],\r\n            sight: 5,\r\n        },\r\n        {\r\n            char: \"s\",\r\n            disposition: Disposition.Aggressive,\r\n            factions: [\r\n                Faction.Monster,\r\n            ],\r\n            hostileFactions: [],\r\n            sight: 10,\r\n        },\r\n        {\r\n            char: \"r\",\r\n            disposition: Disposition.Aggressive,\r\n            factions: [\r\n                Faction.Monster,\r\n            ],\r\n            hostileFactions: [],\r\n            sight: 10,\r\n        },\r\n        {\r\n            char: \"o\",\r\n            disposition: Disposition.Aggressive,\r\n            factions: [\r\n                Faction.Monster,\r\n                Faction.Orc,\r\n            ],\r\n            hostileFactions: [\r\n                Faction.Player,\r\n                Faction.Bugbear,\r\n            ],\r\n            sight: 10,\r\n        },\r\n        {\r\n            char: \"b\",\r\n            disposition: Disposition.Aggressive,\r\n            factions: [\r\n                Faction.Monster,\r\n                Faction.Bugbear,\r\n            ],\r\n            hostileFactions: [\r\n                Faction.Player,\r\n                Faction.Orc,\r\n            ],\r\n            sight: 10,\r\n        },\r\n    ],\r\n    cellInfo: [\r\n        {\r\n            char: \" \",\r\n            color: \"#ffffff\",\r\n            solid: false,\r\n        },\r\n        {\r\n            char: \".\",\r\n            color: \"#ffffff\",\r\n            solid: false,\r\n        },\r\n        {\r\n            char: \"^\",\r\n            color: \"#50ff50\",\r\n            solid: false,\r\n        },\r\n        {\r\n            char: \"#\",\r\n            color: \"#ffffff\",\r\n            solid: true,\r\n        },\r\n        {\r\n            char: \"-\",\r\n            color: \"#ffffff\",\r\n            solid: false,\r\n        },\r\n        {\r\n            char: \"+\",\r\n            color: \"#ffffff\",\r\n            solid: true,\r\n        },\r\n    ],\r\n    classInfo: [\r\n        {\r\n            color: \"#ffffff\",\r\n        },\r\n        {\r\n            color: \"#ffffff\",\r\n        },\r\n        {\r\n            color: \"#ffff00\",\r\n        },\r\n    ],\r\n    itemInfo: [\r\n        {\r\n            char: \"%\",\r\n        },\r\n        {\r\n            char: \"|\",\r\n        },\r\n        {\r\n            char: \"/\",\r\n        },\r\n        {\r\n            char: \")\",\r\n        },\r\n        {\r\n            char: \"}\",\r\n        },\r\n    ],\r\n    stairInfo: [\r\n        {\r\n            char: \">\",\r\n            color: \"#ffffff\",\r\n        },\r\n        {\r\n            char: \"<\",\r\n            color: \"#ffffff\",\r\n        },\r\n    ],\r\n};\r\nexport let game = {\r\n    currentActorId: 1,\r\n    currentStairId: 0,\r\n    fontSize: 24,\r\n    godMode: true,\r\n    ignoreFov: false,\r\n    messages: [],\r\n    stopTime: false,\r\n    turn: 0,\r\n    world: undefined,\r\n};\r\nexport function load() {\r\n    game = JSON.parse(localStorage.getItem(\"game\"));\r\n    console.log(game);\r\n}\r\nexport function log(area, location, message) {\r\n    const playerContext = findActor(0);\r\n    const player = playerContext.actor;\r\n    if ((area === playerContext.level || area === playerContext.chunk)\r\n        && lineOfSight(area, player, radiansBetween(player, location), config.actorInfo[player.actorType].sight)\r\n            .find((coord) => coord.x === location.x && coord.y === location.y)) {\r\n        game.messages.push(message);\r\n        if (game.messages.length > ui.maxMessages) {\r\n            game.messages.shift();\r\n        }\r\n    }\r\n}\r\nexport function save() {\r\n    localStorage.setItem(\"game\", JSON.stringify(game));\r\n    console.log(JSON.stringify(game));\r\n}\r\nexport function tick() {\r\n    if (!game.stopTime) {\r\n        game.world.chunks.forEach((chunks) => {\r\n            chunks.forEach((chunk) => {\r\n                chunk.actors.forEach((actor) => {\r\n                    if (actor.id !== 0) {\r\n                        actor_tick(actor, chunk);\r\n                    }\r\n                });\r\n                chunk.dungeons.forEach((dungeon) => {\r\n                    dungeon.levels.forEach((level) => {\r\n                        level.actors.forEach((actor) => {\r\n                            if (actor.id !== 0) {\r\n                                actor_tick(actor, chunk, dungeon, level);\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n        game.turn++;\r\n    }\r\n}\r\nexport const ui = {\r\n    inventorySwapFirst: -1,\r\n    inventorySwapSecond: -1,\r\n    maxMessages: 10,\r\n    mode: UIMode.Default,\r\n    target: { x: 0, y: 0 },\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/game.ts\n// module id = 0\n// module chunks = 0","export function degreesBetween(coord1, coord2) {\r\n    return toDegrees(radiansBetween(coord1, coord2));\r\n}\r\nexport function distanceBetweenSquared(coord1, coord2) {\r\n    return Math.pow(coord2.x - coord1.x, 2) + Math.pow(coord2.y - coord1.y, 2);\r\n}\r\nexport function distanceBetween(coord1, coord2) {\r\n    return Math.sqrt(distanceBetweenSquared(coord1, coord2));\r\n}\r\nexport function isInside(coord, rect) {\r\n    return Math.min(rect.left, rect.left + rect.width) <= coord.x\r\n        && coord.x < Math.max(rect.left, rect.left + rect.width)\r\n        && Math.min(rect.top, rect.top + rect.height) <= coord.y\r\n        && coord.y < Math.max(rect.top, rect.top + rect.height);\r\n}\r\nexport function radiansBetween(coord1, coord2) {\r\n    return Math.atan2(coord2.y - coord1.y, coord2.x - coord1.x);\r\n}\r\nexport function randomFloat(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\r\nexport function randomInt(min, max) {\r\n    return Math.floor(randomFloat(Math.ceil(min), Math.floor(max)));\r\n}\r\nexport function toDegrees(radians) {\r\n    return radians * 180 / Math.PI;\r\n}\r\nexport function toRadians(degrees) {\r\n    return degrees * Math.PI / 180;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/math.ts\n// module id = 1\n// module chunks = 0","export var ActorType;\r\n(function (ActorType) {\r\n    ActorType[ActorType[\"Player\"] = 0] = \"Player\";\r\n    ActorType[ActorType[\"Slime\"] = 1] = \"Slime\";\r\n    ActorType[ActorType[\"Rat\"] = 2] = \"Rat\";\r\n    ActorType[ActorType[\"Orc\"] = 3] = \"Orc\";\r\n    ActorType[ActorType[\"Bugbear\"] = 4] = \"Bugbear\";\r\n})(ActorType || (ActorType = {}));\r\nexport var CellType;\r\n(function (CellType) {\r\n    CellType[CellType[\"Empty\"] = 0] = \"Empty\";\r\n    CellType[CellType[\"Floor\"] = 1] = \"Floor\";\r\n    CellType[CellType[\"Grass\"] = 2] = \"Grass\";\r\n    CellType[CellType[\"Wall\"] = 3] = \"Wall\";\r\n    CellType[CellType[\"DoorOpen\"] = 4] = \"DoorOpen\";\r\n    CellType[CellType[\"DoorClosed\"] = 5] = \"DoorClosed\";\r\n})(CellType || (CellType = {}));\r\nexport var Class;\r\n(function (Class) {\r\n    Class[Class[\"None\"] = 0] = \"None\";\r\n    Class[Class[\"Warrior\"] = 1] = \"Warrior\";\r\n    Class[Class[\"Shaman\"] = 2] = \"Shaman\";\r\n})(Class || (Class = {}));\r\nexport var Disposition;\r\n(function (Disposition) {\r\n    Disposition[Disposition[\"Passive\"] = 0] = \"Passive\";\r\n    Disposition[Disposition[\"Aggressive\"] = 1] = \"Aggressive\";\r\n    Disposition[Disposition[\"Cowardly\"] = 2] = \"Cowardly\";\r\n})(Disposition || (Disposition = {}));\r\nexport var Faction;\r\n(function (Faction) {\r\n    Faction[Faction[\"Player\"] = 0] = \"Player\";\r\n    Faction[Faction[\"Monster\"] = 1] = \"Monster\";\r\n    Faction[Faction[\"Bugbear\"] = 2] = \"Bugbear\";\r\n    Faction[Faction[\"Orc\"] = 3] = \"Orc\";\r\n})(Faction || (Faction = {}));\r\nexport var ItemType;\r\n(function (ItemType) {\r\n    ItemType[ItemType[\"Corpse\"] = 0] = \"Corpse\";\r\n    ItemType[ItemType[\"Sword\"] = 1] = \"Sword\";\r\n    ItemType[ItemType[\"Spear\"] = 2] = \"Spear\";\r\n    ItemType[ItemType[\"Shield\"] = 3] = \"Shield\";\r\n    ItemType[ItemType[\"Bow\"] = 4] = \"Bow\";\r\n})(ItemType || (ItemType = {}));\r\nexport var StairDirection;\r\n(function (StairDirection) {\r\n    StairDirection[StairDirection[\"Down\"] = 0] = \"Down\";\r\n    StairDirection[StairDirection[\"Up\"] = 1] = \"Up\";\r\n})(StairDirection || (StairDirection = {}));\r\nexport var UIMode;\r\n(function (UIMode) {\r\n    UIMode[UIMode[\"Default\"] = 0] = \"Default\";\r\n    UIMode[UIMode[\"Target\"] = 1] = \"Target\";\r\n    UIMode[UIMode[\"Inventory\"] = 2] = \"Inventory\";\r\n    UIMode[UIMode[\"InventoryDrop\"] = 3] = \"InventoryDrop\";\r\n    UIMode[UIMode[\"InventoryEquip\"] = 4] = \"InventoryEquip\";\r\n    UIMode[UIMode[\"InventoryUnequip\"] = 5] = \"InventoryUnequip\";\r\n    UIMode[UIMode[\"InventorySwapFirst\"] = 6] = \"InventorySwapFirst\";\r\n    UIMode[UIMode[\"InventorySwapSecond\"] = 7] = \"InventorySwapSecond\";\r\n    UIMode[UIMode[\"Character\"] = 8] = \"Character\";\r\n})(UIMode || (UIMode = {}));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/types.ts\n// module id = 2\n// module chunks = 0","import { config } from \"./game\";\r\nimport { distanceBetweenSquared, toRadians } from \"./math\";\r\nexport function aStar(area, start, goal) {\r\n    const coords = [];\r\n    for (let x = 0; x < area.width; x++) {\r\n        coords[x] = [];\r\n        for (let y = 0; y < area.height; y++) {\r\n            coords[x][y] = { x, y };\r\n        }\r\n    }\r\n    const closedSet = [];\r\n    const openSet = [\r\n        coords[start.x][start.y],\r\n    ];\r\n    const cameFrom = new Map();\r\n    const gScore = new Map();\r\n    const fScore = new Map();\r\n    for (let x = 0; x < area.width; x++) {\r\n        for (let y = 0; y < area.height; y++) {\r\n            gScore.set(coords[x][y], Infinity);\r\n            fScore.set(coords[x][y], Infinity);\r\n        }\r\n    }\r\n    gScore.set(coords[start.x][start.y], 0);\r\n    fScore.set(coords[start.x][start.y], distanceBetweenSquared(start, goal));\r\n    let passes = 0;\r\n    while (openSet.length > 0) {\r\n        let current;\r\n        let lowestFScore = Infinity;\r\n        for (let i = 0; i < openSet.length; i++) {\r\n            const value = fScore.get(openSet[i]);\r\n            if (value < lowestFScore) {\r\n                current = openSet[i];\r\n                lowestFScore = value;\r\n            }\r\n        }\r\n        if (current === coords[goal.x][goal.y] || passes > Infinity) {\r\n            const path = [\r\n                current,\r\n            ];\r\n            while (cameFrom.get(current)) {\r\n                current = cameFrom.get(current);\r\n                path.push(current);\r\n            }\r\n            return path;\r\n        }\r\n        openSet.splice(openSet.indexOf(current), 1);\r\n        closedSet.push(current);\r\n        const neighbors = [];\r\n        if (current.y - 1 >= 0) {\r\n            neighbors.push(coords[current.x][current.y - 1]);\r\n        }\r\n        if (current.x + 1 < area.width) {\r\n            neighbors.push(coords[current.x + 1][current.y]);\r\n        }\r\n        if (current.y + 1 < area.height) {\r\n            neighbors.push(coords[current.x][current.y + 1]);\r\n        }\r\n        if (current.x - 1 >= 0) {\r\n            neighbors.push(coords[current.x - 1][current.y]);\r\n        }\r\n        neighbors.filter((neighbor) => !config.cellInfo[area.cells[neighbor.x][neighbor.y].type].solid\r\n            && !area.actors.some((actor) => actor.x === neighbor.x && actor.y === neighbor.y\r\n                && actor.x !== goal.x && actor.y !== goal.y)\r\n            && !area.chests.some((chest) => chest.x === neighbor.x && chest.y === neighbor.y\r\n                && chest.x !== goal.x && chest.y !== goal.y))\r\n            .forEach((neighbor) => {\r\n            if (closedSet.indexOf(neighbor) === -1) {\r\n                if (openSet.indexOf(neighbor) === -1) {\r\n                    openSet.push(neighbor);\r\n                }\r\n                const tentativeGScore = gScore.get(current) + distanceBetweenSquared(current, neighbor);\r\n                if (tentativeGScore < gScore.get(neighbor)) {\r\n                    if (current.x !== start.x || current.y !== start.y) {\r\n                        cameFrom.set(neighbor, current);\r\n                    }\r\n                    gScore.set(neighbor, tentativeGScore);\r\n                    fScore.set(neighbor, gScore.get(neighbor) + distanceBetweenSquared(neighbor, goal));\r\n                }\r\n            }\r\n        });\r\n        passes++;\r\n    }\r\n    return undefined;\r\n}\r\nexport function fieldOfView(area, origin, accuracy, range) {\r\n    const coords = [];\r\n    for (let degrees = 0; degrees < 360; degrees += accuracy) {\r\n        coords.push(...lineOfSight(area, origin, toRadians(degrees), range)\r\n            .filter((coord) => !coords.some((c) => c.x === coord.x && c.y === coord.y)));\r\n    }\r\n    return coords;\r\n}\r\nexport function lineOfSight(area, origin, radians, range) {\r\n    const coords = [];\r\n    const current = {\r\n        x: origin.x + 0.5,\r\n        y: origin.y + 0.5,\r\n    };\r\n    const delta = {\r\n        x: Math.cos(radians),\r\n        y: Math.sin(radians),\r\n    };\r\n    for (let i = 0; i < range; i++) {\r\n        const coord = {\r\n            x: Math.trunc(current.x),\r\n            y: Math.trunc(current.y),\r\n        };\r\n        if (coord.x >= 0 && coord.x < area.width\r\n            && coord.y >= 0 && coord.y < area.height) {\r\n            if (!coords.some((c) => c.x === coord.x && c.y === coord.y)) {\r\n                coords.push(coord);\r\n            }\r\n            if (config.cellInfo[area.cells[coord.x][coord.y].type].solid) {\r\n                break;\r\n            }\r\n            current.x += delta.x;\r\n            current.y += delta.y;\r\n        }\r\n    }\r\n    return coords;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/algorithms.ts\n// module id = 3\n// module chunks = 0","import { game } from \"./game\";\r\nimport { StairDirection } from \"./types\";\r\nexport function findActor(id) {\r\n    for (const chunks of game.world.chunks) {\r\n        for (const chunk of chunks) {\r\n            for (const actor of chunk.actors) {\r\n                if (actor.id === id) {\r\n                    const actorContext = {\r\n                        actor,\r\n                        chunk,\r\n                    };\r\n                    return actorContext;\r\n                }\r\n            }\r\n            for (const dungeon of chunk.dungeons) {\r\n                for (const level of dungeon.levels) {\r\n                    for (const actor of level.actors) {\r\n                        if (actor.id === id) {\r\n                            const actorContext = {\r\n                                actor,\r\n                                chunk,\r\n                                dungeon,\r\n                                level,\r\n                            };\r\n                            return actorContext;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexport function findStair(id, direction) {\r\n    for (const chunks of game.world.chunks) {\r\n        for (const chunk of chunks) {\r\n            if (direction === StairDirection.Down) {\r\n                for (const stair of chunk.stairsDown) {\r\n                    if (stair.id === id) {\r\n                        const stairContext = {\r\n                            chunk,\r\n                            stair,\r\n                        };\r\n                        return stairContext;\r\n                    }\r\n                }\r\n            }\r\n            for (const dungeon of chunk.dungeons) {\r\n                for (const level of dungeon.levels) {\r\n                    if (direction === StairDirection.Down) {\r\n                        if (level.stairDown.id === id) {\r\n                            const stairContext = {\r\n                                chunk,\r\n                                dungeon,\r\n                                level,\r\n                                stair: level.stairDown,\r\n                            };\r\n                            return stairContext;\r\n                        }\r\n                    }\r\n                    else if (direction === StairDirection.Up) {\r\n                        if (level.stairUp.id === id) {\r\n                            const stairContext = {\r\n                                chunk,\r\n                                dungeon,\r\n                                level,\r\n                                stair: level.stairUp,\r\n                            };\r\n                            return stairContext;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/utils.ts\n// module id = 4\n// module chunks = 0","import { aStar, lineOfSight } from \"./algorithms\";\r\nimport { config, game, log } from \"./game\";\r\nimport { createDungeon, createLevel } from \"./generators\";\r\nimport { radiansBetween, randomFloat } from \"./math\";\r\nimport { CellType, Class, Disposition, ItemType, StairDirection } from \"./types\";\r\nimport { findStair } from \"./utils\";\r\nexport function ascend(actor, stair, area) {\r\n    log(area, actor, `${actor.name} ascends`);\r\n    const stairContext = findStair(stair.id, StairDirection.Down);\r\n    const newArea = stairContext.level || stairContext.chunk;\r\n    moveToArea(actor, area, newArea, stairContext.stair);\r\n}\r\nexport function attack(actor, target, area) {\r\n    const actorInfo = config.actorInfo[actor.actorType];\r\n    const targetInfo = config.actorInfo[target.actorType];\r\n    if (randomFloat(0, 1) < 0.5) {\r\n        if (target.id === 0 && game.godMode) {\r\n            log(area, actor, `${actor.name} cannot kill ${target.name}`);\r\n        }\r\n        else {\r\n            log(area, actor, `${actor.name} kills ${target.name}`);\r\n            target.inventory.forEach((item) => {\r\n                dropItem(target, item, area);\r\n            });\r\n            const corpse = Object.assign({}, target, { equipped: false, itemType: ItemType.Corpse, name: target.name + \" corpse\" });\r\n            area.actors.splice(area.actors.indexOf(target), 1);\r\n            area.items.push(corpse);\r\n        }\r\n    }\r\n    else {\r\n        log(area, actor, `${actor.name} misses ${target.name}`);\r\n    }\r\n    if (!target.hostileActorIds.some((id) => id === actor.id)) {\r\n        log(area, actor, `${actor.name} is now hostile to ${target.name}`);\r\n        target.hostileActorIds.push(actor.id);\r\n    }\r\n}\r\nexport function calcStats(actor) {\r\n    const stats = {\r\n        armor: actor.level,\r\n        attunement: actor.level,\r\n        avoidance: actor.level,\r\n        charisma: actor.level,\r\n        encumbrance: actor.level,\r\n        endurance: actor.level,\r\n        energy: actor.level,\r\n        health: actor.level,\r\n        intellect: actor.level,\r\n        luck: actor.level,\r\n        mana: actor.level,\r\n        precision: actor.level,\r\n        resistance: actor.level,\r\n        stamina: actor.level,\r\n        strength: actor.level,\r\n    };\r\n    return stats;\r\n}\r\nexport function descend(actor, stair, chunk, dungeon, level) {\r\n    const area = level || chunk;\r\n    log(area, actor, `${actor.name} descends`);\r\n    const stairContext = findStair(stair.id, StairDirection.Up);\r\n    if (stairContext) {\r\n        moveToArea(actor, area, stairContext.level, stairContext.level.stairUp);\r\n    }\r\n    else {\r\n        let newDungeon;\r\n        if (dungeon) {\r\n            newDungeon = dungeon;\r\n        }\r\n        else {\r\n            newDungeon = createDungeon();\r\n            chunk.dungeons.push(newDungeon);\r\n        }\r\n        const newLevel = createLevel(stair.id);\r\n        newDungeon.levels.push(newLevel);\r\n        moveToArea(actor, area, newLevel, newLevel.stairUp);\r\n    }\r\n}\r\nexport function dropItem(actor, item, area) {\r\n    log(area, actor, `${actor.name} drops a ${item.name}`);\r\n    item.x = actor.x;\r\n    item.y = actor.y;\r\n    item.equipped = false;\r\n    actor.inventory.splice(actor.inventory.indexOf(item), 1);\r\n    area.items.push(item);\r\n}\r\nexport function getInventoryChar(actor, item) {\r\n    return String.fromCharCode(97 + actor.inventory.indexOf(item));\r\n}\r\nexport function moveToCell(actor, coord, chunk, dungeon, level) {\r\n    const actorInfo = config.actorInfo[actor.actorType];\r\n    const area = level || chunk;\r\n    if (coord.x >= 0 && coord.x < area.width && coord.y >= 0 && coord.y < area.height) {\r\n        {\r\n            const cell = area.cells[coord.x][coord.y];\r\n            switch (cell.type) {\r\n                case CellType.Wall:\r\n                    return;\r\n                case CellType.DoorClosed:\r\n                    if (randomFloat(0, 1) < 0.5) {\r\n                        log(area, actor, `${actor.name} opens the door`);\r\n                        cell.type = CellType.DoorOpen;\r\n                    }\r\n                    else {\r\n                        log(area, actor, `${actor.name} can't open the door`);\r\n                    }\r\n                    return;\r\n            }\r\n        }\r\n        if (area.actors.some((target) => {\r\n            if (target !== actor\r\n                && target.x === coord.x && target.y === coord.y) {\r\n                if (config.actorInfo[target.actorType].factions.some((faction) => actorInfo.hostileFactions.indexOf(faction) > -1)\r\n                    || actor.hostileActorIds.some((id) => id === target.id)) {\r\n                    attack(actor, target, area);\r\n                }\r\n                return true;\r\n            }\r\n        })) {\r\n            return;\r\n        }\r\n        if (area.chests.some((chest) => {\r\n            if (chest.x === coord.x && chest.y === coord.y) {\r\n                openChest(actor, chest, area);\r\n                return true;\r\n            }\r\n        })) {\r\n            return;\r\n        }\r\n        if (level) {\r\n            if (level.stairDown\r\n                && level.stairDown.x === coord.x && level.stairDown.y === coord.y) {\r\n                descend(actor, level.stairDown, chunk, dungeon, level);\r\n                return;\r\n            }\r\n            if (level.stairUp.x === coord.x && level.stairUp.y === coord.y) {\r\n                ascend(actor, level.stairUp, area);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            if (chunk.stairsDown.some((stairDown) => {\r\n                if (stairDown.x === coord.x && stairDown.y === coord.y) {\r\n                    descend(actor, stairDown, chunk, dungeon, level);\r\n                    return true;\r\n                }\r\n            })) {\r\n                return;\r\n            }\r\n        }\r\n        {\r\n            const itemNames = area.items.filter((item) => item.x === coord.x && item.y === coord.y)\r\n                .map((item) => item.name).join(\", \");\r\n            if (itemNames) {\r\n                log(area, actor, `${actor.name} sees ${itemNames}`);\r\n            }\r\n        }\r\n        actor.x = coord.x;\r\n        actor.y = coord.y;\r\n    }\r\n}\r\nexport function moveToArea(actor, area, newArea, newCoord) {\r\n    area.actors.splice(area.actors.indexOf(actor), 1);\r\n    newArea.actors.push(actor);\r\n    actor.x = newCoord.x;\r\n    actor.y = newCoord.y;\r\n}\r\nexport function openChest(actor, chest, area) {\r\n    if (randomFloat(0, 1) < 0.5) {\r\n        log(area, actor, `${actor.name} opens the chest`);\r\n        area.chests.splice(area.chests.indexOf(chest), 1);\r\n        if (chest.loot) {\r\n            if (actor.inventory.length < 26) {\r\n                log(area, actor, `${actor.name} loots a ${chest.loot.name}`);\r\n                actor.inventory.push(chest.loot);\r\n            }\r\n            else {\r\n                log(area, actor, `${actor.name}'s inventory is full`);\r\n            }\r\n        }\r\n        else {\r\n            log(area, actor, `${actor.name} sees nothing inside`);\r\n        }\r\n    }\r\n    else {\r\n        log(area, actor, `${actor.name} can't open the chest`);\r\n    }\r\n}\r\nexport function pathfind(actor, coord, chunk, dungeon, level) {\r\n    const area = level || chunk;\r\n    const path = aStar(area, actor, coord);\r\n    if (path && path.length) {\r\n        moveToCell(actor, path.pop(), chunk, dungeon, level);\r\n        return true;\r\n    }\r\n}\r\nexport function pickUpItem(actor, item, area) {\r\n    log(area, actor, `${actor.name} picks up ${item.name}`);\r\n    item.x = undefined;\r\n    item.y = undefined;\r\n    area.items.splice(area.items.indexOf(item), 1);\r\n    actor.inventory.push(item);\r\n}\r\nexport function resurrect(actor, corpse, area) {\r\n    const newActor = {\r\n        actorType: corpse.actorType,\r\n        class: corpse.class,\r\n        experience: corpse.experience,\r\n        hostileActorIds: corpse.hostileActorIds,\r\n        id: corpse.id,\r\n        inventory: corpse.inventory,\r\n        level: corpse.level,\r\n        name: corpse.name.replace(\" corpse\", \"\"),\r\n        x: corpse.x,\r\n        y: corpse.y,\r\n    };\r\n    log(area, actor, `${actor.name} ressurects ${newActor.name}`);\r\n    area.items.splice(area.items.indexOf(corpse), 1);\r\n    area.actors.push(newActor);\r\n}\r\nexport function tick(actor, chunk, dungeon, level) {\r\n    const actorInfo = config.actorInfo[actor.actorType];\r\n    const area = level || chunk;\r\n    switch (actor.class) {\r\n        case Class.Warrior:\r\n            break;\r\n        case Class.Shaman:\r\n            if (randomFloat(0, 1) < 0.5) {\r\n                const corpses = area.items.filter((item) => \"id\" in item\r\n                    && config.actorInfo[item.actorType].factions.every((faction) => actorInfo.hostileFactions.indexOf(faction) === -1)\r\n                    && lineOfSight(area, actor, radiansBetween(actor, item), actorInfo.sight)\r\n                        .some((coord) => coord.x === item.x && coord.y === item.y))\r\n                    .map((item) => item);\r\n                if (corpses.length) {\r\n                    if (randomFloat(0, 1) < 0.5) {\r\n                        resurrect(actor, corpses[0], area);\r\n                    }\r\n                    else {\r\n                        log(area, actor, `${actor.name} fails to ressurect ${corpses[0].name}`);\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    switch (actorInfo.disposition) {\r\n        case Disposition.Passive:\r\n            break;\r\n        case Disposition.Aggressive:\r\n            if (randomFloat(0, 1) < 0.5) {\r\n                const targets = area.actors.filter((target) => target !== actor\r\n                    && (config.actorInfo[target.actorType].factions.some((faction) => actorInfo.hostileFactions.indexOf(faction) > -1)\r\n                        || actor.hostileActorIds.some((id) => id === target.id))\r\n                    && lineOfSight(area, actor, radiansBetween(actor, target), actorInfo.sight)\r\n                        .some((coord) => coord.x === target.x && coord.y === target.y));\r\n                if (targets.length) {\r\n                    log(area, actor, `${actor.name} spots ${targets[0].name}`);\r\n                    if (pathfind(actor, targets[0], chunk, dungeon, level)) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case Disposition.Cowardly:\r\n            break;\r\n    }\r\n    if (randomFloat(0, 1) < 0.5) {\r\n        const targets = area.chests.filter((chest) => lineOfSight(area, actor, radiansBetween(actor, chest), actorInfo.sight)\r\n            .some((coord) => coord.x === chest.x && coord.y === chest.y))\r\n            .map((chest) => ({ x: chest.x, y: chest.y, name: \"chest\" }))\r\n            || area.items.filter((item) => !(\"id\" in item)\r\n                && lineOfSight(area, actor, radiansBetween(actor, item), actorInfo.sight)\r\n                    .some((coord) => coord.x === item.x && coord.y === item.y));\r\n        if (targets.length) {\r\n            log(area, actor, `${actor.name} spots ${targets[0].name}`);\r\n            if (pathfind(actor, targets[0], chunk, dungeon, level)) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (randomFloat(0, 1) < 0.5 && area.items.some((item) => {\r\n        if (item.x === actor.x && item.y === actor.y) {\r\n            pickUpItem(actor, item, area);\r\n            return true;\r\n        }\r\n    })) {\r\n        return;\r\n    }\r\n    if (randomFloat(0, 1) < 0.5 && actor.inventory.some((item) => {\r\n        if (item.name.includes(\"corpse\")) {\r\n            dropItem(actor, item, area);\r\n            return true;\r\n        }\r\n    })) {\r\n        return;\r\n    }\r\n    if (randomFloat(0, 1) < 0.5) {\r\n        const roll = randomFloat(0, 1);\r\n        if (roll < 0.25) {\r\n            moveToCell(actor, { x: actor.x, y: actor.y - 1 }, chunk, dungeon, level);\r\n        }\r\n        else if (roll < 0.5) {\r\n            moveToCell(actor, { x: actor.x + 1, y: actor.y }, chunk, dungeon, level);\r\n        }\r\n        else if (roll < 0.75) {\r\n            moveToCell(actor, { x: actor.x, y: actor.y + 1 }, chunk, dungeon, level);\r\n        }\r\n        else {\r\n            moveToCell(actor, { x: actor.x - 1, y: actor.y }, chunk, dungeon, level);\r\n        }\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/actors.ts\n// module id = 5\n// module chunks = 0","import { game } from \"./game\";\r\nimport { randomFloat, randomInt } from \"./math\";\r\nimport { ActorType, CellType, Class, ItemType, StairDirection } from \"./types\";\r\nexport function createChunk(opts) {\r\n    const width = opts && opts.width || 100;\r\n    const height = opts && opts.height || 100;\r\n    const dungeonAmount = opts && opts.dungeonAmount || 100;\r\n    const chunk = {\r\n        actors: [],\r\n        cells: [[]],\r\n        chests: [],\r\n        dungeons: [],\r\n        height,\r\n        items: [],\r\n        stairsDown: [],\r\n        width,\r\n    };\r\n    for (let x = 0; x < chunk.width; x++) {\r\n        chunk.cells[x] = [];\r\n        for (let y = 0; y < chunk.height; y++) {\r\n            chunk.cells[x][y] = {\r\n                discovered: false,\r\n                type: CellType.Grass,\r\n            };\r\n        }\r\n    }\r\n    for (let i = 0; i < dungeonAmount; i++) {\r\n        chunk.stairsDown.push({\r\n            direction: StairDirection.Down,\r\n            id: game.currentStairId++,\r\n            x: randomInt(0, chunk.width),\r\n            y: randomInt(0, chunk.height),\r\n        });\r\n    }\r\n    return chunk;\r\n}\r\nexport function createDungeon(opts) {\r\n    const name = opts && opts.name;\r\n    const maxLevels = opts && opts.maxLevels || 1;\r\n    const dungeon = {\r\n        levels: [],\r\n        maxLevels,\r\n        name,\r\n    };\r\n    if (!dungeon.name) {\r\n        const roll = randomFloat(0, 1);\r\n        if (roll < 0.25) {\r\n            dungeon.name = \"cool dungeon\";\r\n        }\r\n        else if (roll < 0.5) {\r\n            dungeon.name = \"awesome dungeon\";\r\n        }\r\n        else if (roll < 0.75) {\r\n            dungeon.name = \"terrible dungeon\";\r\n        }\r\n        else {\r\n            dungeon.name = \"low effort dungeon\";\r\n        }\r\n    }\r\n    return dungeon;\r\n}\r\nexport function createLevel(stairDownId, opts) {\r\n    const width = opts && opts.width || 50;\r\n    const height = opts && opts.height || 50;\r\n    const roomAttempts = opts && opts.roomAttempts || 20;\r\n    const minRoomSize = opts && opts.minRoomSize || 5;\r\n    const maxRoomSize = opts && opts.maxRoomSize || 15;\r\n    const preventOverlap = opts && opts.preventOverlap || true;\r\n    const litRooms = opts && opts.litRooms || false;\r\n    const doorChance = opts && opts.doorChance || 0.5;\r\n    const monsterAmount = opts && opts.monsterAmount || 5;\r\n    const chestAmount = opts && opts.chestAmount || 5;\r\n    const level = {\r\n        actors: [],\r\n        cells: [[]],\r\n        chests: [],\r\n        height,\r\n        items: [],\r\n        litRooms,\r\n        rooms: [],\r\n        stairDown: undefined,\r\n        stairUp: undefined,\r\n        width,\r\n    };\r\n    for (let x = 0; x < level.width; x++) {\r\n        level.cells[x] = [];\r\n        for (let y = 0; y < level.height; y++) {\r\n            level.cells[x][y] = {\r\n                discovered: false,\r\n                type: CellType.Empty,\r\n            };\r\n        }\r\n    }\r\n    for (let i = 0; i < roomAttempts || level.rooms.length < 2; i++) {\r\n        const room = {\r\n            height: randomInt(minRoomSize, maxRoomSize),\r\n            left: randomInt(0, level.width),\r\n            top: randomInt(0, level.height),\r\n            width: randomInt(minRoomSize, maxRoomSize),\r\n        };\r\n        if (room.left < 1 || room.left + room.width > level.width - 1 || room.top < 1\r\n            || room.top + room.height > level.height - 1) {\r\n            continue;\r\n        }\r\n        if (preventOverlap && (() => {\r\n            for (let x = room.left; x < room.left + room.width; x++) {\r\n                for (let y = room.top; y < room.top + room.height; y++) {\r\n                    if (level.cells[x][y].type === CellType.Floor) {\r\n                        return true;\r\n                    }\r\n                    if (level.cells[x][y - 1].type === CellType.Floor) {\r\n                        return true;\r\n                    }\r\n                    if (level.cells[x + 1][y].type === CellType.Floor) {\r\n                        return true;\r\n                    }\r\n                    if (level.cells[x][y + 1].type === CellType.Floor) {\r\n                        return true;\r\n                    }\r\n                    if (level.cells[x - 1][y].type === CellType.Floor) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        })()) {\r\n            continue;\r\n        }\r\n        for (let x = room.left; x < room.left + room.width; x++) {\r\n            for (let y = room.top; y < room.top + room.height; y++) {\r\n                level.cells[x][y].type = CellType.Floor;\r\n            }\r\n        }\r\n        level.rooms.push(room);\r\n    }\r\n    for (let i = 0; i < level.rooms.length - 1; i++) {\r\n        let x1 = randomInt(level.rooms[i].left, level.rooms[i].left + level.rooms[i].width);\r\n        let y1 = randomInt(level.rooms[i].top, level.rooms[i].top + level.rooms[i].height);\r\n        let x2 = randomInt(level.rooms[i + 1].left, level.rooms[i + 1].left + level.rooms[i + 1].width);\r\n        let y2 = randomInt(level.rooms[i + 1].top, level.rooms[i + 1].top + level.rooms[i + 1].height);\r\n        if (x1 > x2) {\r\n            const t = x1;\r\n            x1 = x2;\r\n            x2 = t;\r\n        }\r\n        if (y1 > y2) {\r\n            const t = y1;\r\n            y1 = y2;\r\n            y2 = t;\r\n        }\r\n        for (let x = x1; x <= x2; x++) {\r\n            for (let y = y1; y <= y2; y++) {\r\n                if (x === x1 || x === x2 || y === y1 || y === y2) {\r\n                    level.cells[x][y].type = CellType.Floor;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (let x = 0; x < level.width; x++) {\r\n        for (let y = 0; y < level.height; y++) {\r\n            if (level.cells[x][y].type === CellType.Floor) {\r\n                if (level.cells[x][y - 1].type === CellType.Empty) {\r\n                    level.cells[x][y - 1].type = CellType.Wall;\r\n                }\r\n                if (level.cells[x + 1][y - 1].type === CellType.Empty) {\r\n                    level.cells[x + 1][y - 1].type = CellType.Wall;\r\n                }\r\n                if (level.cells[x + 1][y].type === CellType.Empty) {\r\n                    level.cells[x + 1][y].type = CellType.Wall;\r\n                }\r\n                if (level.cells[x + 1][y + 1].type === CellType.Empty) {\r\n                    level.cells[x + 1][y + 1].type = CellType.Wall;\r\n                }\r\n                if (level.cells[x][y + 1].type === CellType.Empty) {\r\n                    level.cells[x][y + 1].type = CellType.Wall;\r\n                }\r\n                if (level.cells[x - 1][y - 1].type === CellType.Empty) {\r\n                    level.cells[x - 1][y - 1].type = CellType.Wall;\r\n                }\r\n                if (level.cells[x - 1][y].type === CellType.Empty) {\r\n                    level.cells[x - 1][y].type = CellType.Wall;\r\n                }\r\n                if (level.cells[x - 1][y + 1].type === CellType.Empty) {\r\n                    level.cells[x - 1][y + 1].type = CellType.Wall;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (let x = 0; x < level.width; x++) {\r\n        for (let y = 0; y < level.height; y++) {\r\n            if (level.cells[x][y].type === CellType.Floor\r\n                && randomFloat(0, 1) < doorChance) {\r\n                if (level.cells[x][y - 1].type === CellType.Floor\r\n                    && level.cells[x + 1][y - 1].type === CellType.Floor\r\n                    && level.cells[x - 1][y - 1].type === CellType.Floor) {\r\n                    if (level.cells[x - 1][y].type === CellType.Wall\r\n                        && level.cells[x + 1][y].type === CellType.Wall) {\r\n                        level.cells[x][y].type = CellType.DoorClosed;\r\n                    }\r\n                }\r\n                if (level.cells[x + 1][y].type === CellType.Floor\r\n                    && level.cells[x + 1][y - 1].type === CellType.Floor\r\n                    && level.cells[x + 1][y + 1].type === CellType.Floor) {\r\n                    if (level.cells[x][y + 1].type === CellType.Wall\r\n                        && level.cells[x][y - 1].type === CellType.Wall) {\r\n                        level.cells[x][y].type = CellType.DoorClosed;\r\n                    }\r\n                }\r\n                if (level.cells[x][y + 1].type === CellType.Floor\r\n                    && level.cells[x + 1][y + 1].type === CellType.Floor\r\n                    && level.cells[x - 1][y + 1].type === CellType.Floor) {\r\n                    if (level.cells[x - 1][y].type === CellType.Wall\r\n                        && level.cells[x + 1][y].type === CellType.Wall) {\r\n                        level.cells[x][y].type = CellType.DoorClosed;\r\n                    }\r\n                }\r\n                if (level.cells[x - 1][y].type === CellType.Floor\r\n                    && level.cells[x - 1][y - 1].type === CellType.Floor\r\n                    && level.cells[x - 1][y + 1].type === CellType.Floor) {\r\n                    if (level.cells[x][y + 1].type === CellType.Wall\r\n                        && level.cells[x][y - 1].type === CellType.Wall) {\r\n                        level.cells[x][y].type = CellType.DoorClosed;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    level.stairDown = {\r\n        direction: StairDirection.Down,\r\n        id: game.currentStairId++,\r\n        x: randomInt(level.rooms[0].left, level.rooms[0].left + level.rooms[0].width),\r\n        y: randomInt(level.rooms[0].top, level.rooms[0].top + level.rooms[0].height),\r\n    };\r\n    level.stairUp = {\r\n        direction: StairDirection.Up,\r\n        id: stairDownId,\r\n        x: randomInt(level.rooms[level.rooms.length - 1].left, level.rooms[level.rooms.length - 1].left + level.rooms[level.rooms.length - 1].width),\r\n        y: randomInt(level.rooms[level.rooms.length - 1].top, level.rooms[level.rooms.length - 1].top + level.rooms[level.rooms.length - 1].height),\r\n    };\r\n    for (let i = 0; i < monsterAmount; i++) {\r\n        const roomIndex = randomInt(1, level.rooms.length);\r\n        const monster = {\r\n            actorType: undefined,\r\n            class: Class.None,\r\n            experience: 0,\r\n            hostileActorIds: [],\r\n            id: game.currentActorId++,\r\n            inventory: [],\r\n            level: 1,\r\n            name: undefined,\r\n            x: randomInt(level.rooms[roomIndex].left, level.rooms[roomIndex].left + level.rooms[roomIndex].width),\r\n            y: randomInt(level.rooms[roomIndex].top, level.rooms[roomIndex].top + level.rooms[roomIndex].height),\r\n        };\r\n        const roll = randomFloat(0, 1);\r\n        if (roll < 0.25) {\r\n            monster.name = \"rat\";\r\n            monster.actorType = ActorType.Rat;\r\n        }\r\n        else if (roll < 0.50) {\r\n            monster.name = \"slime\";\r\n            monster.actorType = ActorType.Slime;\r\n        }\r\n        else if (roll < 0.75) {\r\n            monster.name = \"orc\";\r\n            monster.actorType = ActorType.Orc;\r\n            if (randomFloat(0, 1) < 0.5) {\r\n                monster.name += \" shaman\";\r\n                monster.class = Class.Shaman;\r\n            }\r\n        }\r\n        else {\r\n            monster.name = \"bugbear\";\r\n            monster.actorType = ActorType.Bugbear;\r\n            if (randomFloat(0, 1) < 0.5) {\r\n                monster.name += \" shaman\";\r\n                monster.class = Class.Shaman;\r\n            }\r\n        }\r\n        level.actors.push(monster);\r\n    }\r\n    for (let i = 0; i < chestAmount; i++) {\r\n        const roomIndex = randomInt(0, level.rooms.length);\r\n        level.chests.push({\r\n            loot: (() => {\r\n                if (randomFloat(0, 1) < 0.5) {\r\n                    const item = {\r\n                        equipped: false,\r\n                        itemType: undefined,\r\n                        name: undefined,\r\n                        x: undefined,\r\n                        y: undefined,\r\n                    };\r\n                    const roll = randomFloat(0, 1);\r\n                    if (roll < 0.25) {\r\n                        item.name = \"sword\";\r\n                        item.itemType = ItemType.Sword;\r\n                    }\r\n                    else if (roll < 0.50) {\r\n                        item.name = \"spear\";\r\n                        item.itemType = ItemType.Spear;\r\n                    }\r\n                    else if (roll < 0.75) {\r\n                        item.name = \"shield\";\r\n                        item.itemType = ItemType.Shield;\r\n                    }\r\n                    else {\r\n                        item.name = \"bow\";\r\n                        item.itemType = ItemType.Bow;\r\n                    }\r\n                    return item;\r\n                }\r\n            })(),\r\n            x: randomInt(level.rooms[roomIndex].left, level.rooms[roomIndex].left + level.rooms[roomIndex].width),\r\n            y: randomInt(level.rooms[roomIndex].top, level.rooms[roomIndex].top + level.rooms[roomIndex].height),\r\n        });\r\n    }\r\n    return level;\r\n}\r\nexport function createWorld(opts) {\r\n    const width = opts && opts.width || 0;\r\n    const height = opts && opts.height || 0;\r\n    const world = {\r\n        chunks: [[]],\r\n        height,\r\n        width,\r\n    };\r\n    for (let x = 0; x < world.width; x++) {\r\n        // world.chunks[x] = [];\r\n        for (let y = 0; y < world.height; y++) {\r\n            // world.chunks[x][y] = createChunk();\r\n        }\r\n    }\r\n    {\r\n        const playerChunk = world.chunks[0][0] = createChunk();\r\n        const player = {\r\n            actorType: ActorType.Player,\r\n            class: Class.Warrior,\r\n            experience: 0,\r\n            hostileActorIds: [],\r\n            id: 0,\r\n            inventory: [],\r\n            level: 1,\r\n            name: \"player\",\r\n            x: Math.round(playerChunk.width / 2),\r\n            y: Math.round(playerChunk.height / 2),\r\n        };\r\n        playerChunk.actors.push(player);\r\n    }\r\n    return world;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/generators.ts\n// module id = 6\n// module chunks = 0","import { calcStats, getInventoryChar } from \"./actors\";\r\nimport { fieldOfView } from \"./algorithms\";\r\nimport { config, game, ui } from \"./game\";\r\nimport { isInside } from \"./math\";\r\nimport { UIMode } from \"./types\";\r\nimport { findActor } from \"./utils\";\r\nconst canvas = document.getElementById(\"game\");\r\nconst ctx = canvas.getContext(\"2d\");\r\nexport function draw(ev) {\r\n    const playerContext = findActor(0);\r\n    const player = playerContext.actor;\r\n    const chunk = playerContext.chunk;\r\n    const dungeon = playerContext.dungeon;\r\n    const level = playerContext.level;\r\n    const area = level || chunk;\r\n    const playerInfo = config.actorInfo[player.actorType];\r\n    canvas.width = window.innerWidth;\r\n    canvas.height = window.innerHeight;\r\n    const view = {\r\n        height: 0,\r\n        left: 0,\r\n        top: 0,\r\n        width: 0,\r\n    };\r\n    view.width = Math.round(canvas.width / game.fontSize);\r\n    view.height = Math.round(canvas.height / game.fontSize);\r\n    view.left = player.x - Math.round(view.width / 2);\r\n    view.top = player.y - Math.round(view.height / 2);\r\n    if (view.left < 0) {\r\n        view.left = 0;\r\n    }\r\n    if (view.left + view.width > area.width) {\r\n        view.left = area.width - view.width;\r\n    }\r\n    if (view.top < 0) {\r\n        view.top = 0;\r\n    }\r\n    if (view.top + view.height > area.height) {\r\n        view.top = area.height - view.height;\r\n    }\r\n    const visibleCells = fieldOfView(area, player, 0.5, playerInfo.sight)\r\n        .map((coord) => area.cells[coord.x][coord.y]);\r\n    visibleCells.forEach((cell) => {\r\n        cell.discovered = true;\r\n    });\r\n    if (game.ignoreFov) {\r\n        for (let x = view.left; x < view.left + view.width; x++) {\r\n            for (let y = view.top; y < view.top + view.height; y++) {\r\n                if (x >= 0 && x < area.width && y >= 0 && y < area.height\r\n                    && visibleCells.indexOf(area.cells[x][y]) === -1) {\r\n                    visibleCells.push(area.cells[x][y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (level && level.litRooms) {\r\n        level.rooms.forEach((room) => {\r\n            if (isInside({ x: player.x, y: player.y }, room)) {\r\n                for (let x = room.left - 1; x < room.left + room.width + 1; x++) {\r\n                    for (let y = room.top - 1; y < room.top + room.height + 1; y++) {\r\n                        if (x >= 0 && x < area.width && y >= 0 && y < area.height) {\r\n                            area.cells[x][y].discovered = true;\r\n                            if (visibleCells.indexOf(area.cells[x][y]) === -1) {\r\n                                visibleCells.push(area.cells[x][y]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.font = game.fontSize + \"px mono\";\r\n    for (let x = view.left; x < view.left + view.width; x++) {\r\n        for (let y = view.top; y < view.top + view.height; y++) {\r\n            if (x >= 0 && x < area.width && y >= 0 && y < area.height) {\r\n                const screen = { x: (x - view.left) * game.fontSize, y: (y - view.top + 1) * game.fontSize };\r\n                if (ui.mode === UIMode.Target) {\r\n                    if (ui.target.x + 1 === x && ui.target.y === y) {\r\n                        ctx.fillStyle = \"#ffffff\";\r\n                        ctx.globalAlpha = 1;\r\n                        ctx.fillText(\"]\", screen.x, screen.y);\r\n                        continue;\r\n                    }\r\n                    if (ui.target.x - 1 === x && ui.target.y === y) {\r\n                        ctx.fillStyle = \"#ffffff\";\r\n                        ctx.globalAlpha = 1;\r\n                        ctx.fillText(\"[\", screen.x, screen.y);\r\n                        continue;\r\n                    }\r\n                }\r\n                if (visibleCells.indexOf(area.cells[x][y]) > -1) {\r\n                    if (area.actors.some((actor) => {\r\n                        if (actor.x === x && actor.y === y) {\r\n                            const actorInfo = config.actorInfo[actor.actorType];\r\n                            const classInfo = config.classInfo[actor.class];\r\n                            ctx.fillStyle = classInfo.color;\r\n                            ctx.globalAlpha = 1;\r\n                            ctx.fillText(actorInfo.char, screen.x, screen.y);\r\n                            return true;\r\n                        }\r\n                    })) {\r\n                        continue;\r\n                    }\r\n                    if (area.chests.some((chest) => {\r\n                        if (chest.x === x && chest.y === y) {\r\n                            ctx.fillStyle = \"#ffffff\";\r\n                            ctx.globalAlpha = 1;\r\n                            ctx.fillText(\"~\", screen.x, screen.y);\r\n                            return true;\r\n                        }\r\n                    })) {\r\n                        continue;\r\n                    }\r\n                    if (area.items.sort((a, b) => {\r\n                        return 0;\r\n                    }).some((item) => {\r\n                        if (item.x === x && item.y === y) {\r\n                            const itemInfo = config.itemInfo[item.itemType];\r\n                            ctx.fillStyle = (\"class\" in item) ? config.classInfo[item.class].color : \"#ffffff\";\r\n                            ctx.globalAlpha = 1;\r\n                            ctx.fillText(itemInfo.char, screen.x, screen.y);\r\n                            return true;\r\n                        }\r\n                    })) {\r\n                        continue;\r\n                    }\r\n                }\r\n                {\r\n                    let stair;\r\n                    if (level) {\r\n                        if (level.stairDown\r\n                            && level.stairDown.x === x && level.stairDown.y === y) {\r\n                            stair = level.stairDown;\r\n                        }\r\n                        if (level.stairUp.x === x && level.stairUp.y === y) {\r\n                            stair = level.stairUp;\r\n                        }\r\n                    }\r\n                    else {\r\n                        chunk.stairsDown.forEach((stairDown) => {\r\n                            if (stairDown.x === x && stairDown.y === y) {\r\n                                stair = stairDown;\r\n                                return;\r\n                            }\r\n                        });\r\n                    }\r\n                    if (stair) {\r\n                        const stairInfo = config.stairInfo[stair.direction];\r\n                        ctx.fillStyle = stairInfo.color;\r\n                        ctx.globalAlpha = visibleCells.indexOf(area.cells[x][y]) > -1 ? 1\r\n                            : area.cells[x][y].discovered ? 0.25\r\n                                : 0;\r\n                        ctx.fillText(stairInfo.char, screen.x, screen.y);\r\n                        continue;\r\n                    }\r\n                }\r\n                const cellInfo = config.cellInfo[area.cells[x][y].type];\r\n                ctx.fillStyle = cellInfo.color;\r\n                ctx.globalAlpha = visibleCells.indexOf(area.cells[x][y]) > -1 ? 1\r\n                    : area.cells[x][y].discovered ? 0.25\r\n                        : 0;\r\n                ctx.fillText(cellInfo.char, screen.x, screen.y);\r\n            }\r\n        }\r\n    }\r\n    game.messages.forEach((message, index) => {\r\n        ctx.fillStyle = \"#ffffff\";\r\n        ctx.globalAlpha = 1;\r\n        ctx.fillText(message, 0, game.fontSize * (index + 1));\r\n    });\r\n    ctx.fillStyle = \"#ffffff\";\r\n    ctx.globalAlpha = 1;\r\n    ctx.fillText(`Dungeon: ${dungeon ? chunk.dungeons.indexOf(dungeon) : \"N/A\"} Level: ${dungeon && level ? dungeon.levels.indexOf(level) : \"N/A\"} Turn: ${game.turn}`, 0, canvas.height);\r\n    if (ui.mode === UIMode.Inventory\r\n        || ui.mode === UIMode.InventoryDrop\r\n        || ui.mode === UIMode.InventoryEquip\r\n        || ui.mode === UIMode.InventorySwapFirst\r\n        || ui.mode === UIMode.InventorySwapSecond\r\n        || ui.mode === UIMode.InventoryUnequip) {\r\n        ctx.fillStyle = \"#ffffff\";\r\n        ctx.globalAlpha = 1;\r\n        player.inventory.forEach((item, index) => {\r\n            ctx.fillText(`${getInventoryChar(player, item)}) ${item.name}${item.equipped ? \" (equipped)\" : \"\"}`, canvas.width - (game.fontSize * 10), (index + 1) * game.fontSize);\r\n        });\r\n    }\r\n    if (ui.mode === UIMode.Character) {\r\n        const stats = calcStats(player);\r\n        ctx.fillStyle = \"#ffffff\";\r\n        ctx.globalAlpha = 1;\r\n        ctx.fillText(`Health: ${stats.health}`, canvas.width - (game.fontSize * 10), game.fontSize);\r\n        ctx.fillText(`Mana: ${stats.mana}`, canvas.width - (game.fontSize * 10), game.fontSize * 2);\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/renderer.ts\n// module id = 7\n// module chunks = 0","import { game } from \"./game\";\r\nimport { createWorld } from \"./generators\";\r\nimport { input } from \"./input\";\r\nimport { draw } from \"./renderer\";\r\ngame.world = createWorld();\r\ndocument.addEventListener(\"keydown\", input);\r\nwindow.addEventListener(\"resize\", draw);\r\ndraw();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/main.ts\n// module id = 8\n// module chunks = 0","import { dropItem, getInventoryChar, moveToCell, pickUpItem, resurrect } from \"./actors\";\r\nimport { lineOfSight } from \"./algorithms\";\r\nimport { config, game, load, log, save, tick, ui } from \"./game\";\r\nimport { radiansBetween } from \"./math\";\r\nimport { draw } from \"./renderer\";\r\nimport { CellType, UIMode } from \"./types\";\r\nimport { findActor } from \"./utils\";\r\nexport function input(ev) {\r\n    const playerContext = findActor(0);\r\n    const player = playerContext.actor;\r\n    const playerInfo = config.actorInfo[player.actorType];\r\n    const chunk = playerContext.chunk;\r\n    const dungeon = playerContext.dungeon;\r\n    const level = playerContext.level;\r\n    const area = level || chunk;\r\n    switch (ui.mode) {\r\n        case UIMode.Default:\r\n            switch (ev.key) {\r\n                case \"ArrowUp\":\r\n                    moveToCell(player, { x: player.x, y: player.y - 1 }, chunk, dungeon, level);\r\n                    tick();\r\n                    break;\r\n                case \"ArrowRight\":\r\n                    moveToCell(player, { x: player.x + 1, y: player.y }, chunk, dungeon, level);\r\n                    tick();\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    moveToCell(player, { x: player.x, y: player.y + 1 }, chunk, dungeon, level);\r\n                    tick();\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    moveToCell(player, { x: player.x - 1, y: player.y }, chunk, dungeon, level);\r\n                    tick();\r\n                    break;\r\n                case \".\":\r\n                    tick();\r\n                    break;\r\n                case \"g\":\r\n                    area.items.forEach((item) => {\r\n                        if (item.x === player.x && item.y === player.y) {\r\n                            pickUpItem(player, item, area);\r\n                        }\r\n                    });\r\n                    tick();\r\n                    break;\r\n                case \"s\":\r\n                    const targets = area.actors.filter((target) => target !== player\r\n                        && lineOfSight(area, player, radiansBetween(player, target), playerInfo.sight)\r\n                            .some((coord) => coord.x === target.x && coord.y === target.y));\r\n                    if (targets.length) {\r\n                        log(area, player, `${player.name} spots ${targets.map((target) => target.name).join(\", \")}`);\r\n                    }\r\n                    else {\r\n                        log(area, player, `${player.name} doesn\"t see anything`);\r\n                    }\r\n                    break;\r\n                case \"r\":\r\n                    area.items.filter((item) => \"id\" in item\r\n                        && lineOfSight(area, player, radiansBetween(player, item), playerInfo.sight)\r\n                            .some((coord) => coord.x === item.x && coord.y === item.y))\r\n                        .map((item) => item)\r\n                        .forEach((corpse) => resurrect(player, corpse, area));\r\n                    tick();\r\n                    break;\r\n                case \"c\":\r\n                    if (area.cells[player.x][player.y].type === CellType.DoorOpen) {\r\n                        log(area, player, `${player.name} closes the door`);\r\n                        area.cells[player.x][player.y].type = CellType.DoorClosed;\r\n                    }\r\n                    tick();\r\n                    break;\r\n                case \"t\":\r\n                    ui.mode = UIMode.Target;\r\n                    ui.target.x = player.x;\r\n                    ui.target.y = player.y;\r\n                    break;\r\n                case \"i\":\r\n                    if (player.inventory.length > 0) {\r\n                        ui.mode = UIMode.Inventory;\r\n                    }\r\n                    break;\r\n                case \"o\":\r\n                    ui.mode = UIMode.Character;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.Target:\r\n            switch (ev.key) {\r\n                case \"ArrowUp\":\r\n                    ui.target.y--;\r\n                    break;\r\n                case \"ArrowRight\":\r\n                    ui.target.x++;\r\n                    break;\r\n                case \"ArrowDown\":\r\n                    ui.target.y++;\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    ui.target.x--;\r\n                    break;\r\n                case \"t\":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.Inventory:\r\n            switch (ev.key) {\r\n                case \"i\":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n                case \"d\":\r\n                    log(area, player, \"select item to drop\");\r\n                    log(area, player, \"press space to cancel\");\r\n                    ui.mode = UIMode.InventoryDrop;\r\n                    break;\r\n                case \"e\":\r\n                    log(area, player, \"select item to equip\");\r\n                    log(area, player, \"press space to cancel\");\r\n                    ui.mode = UIMode.InventoryEquip;\r\n                    break;\r\n                case \"u\":\r\n                    log(area, player, \"select item to unequip\");\r\n                    log(area, player, \"press space to cancel\");\r\n                    ui.mode = UIMode.InventoryUnequip;\r\n                    break;\r\n                case \"s\":\r\n                    log(area, player, \"select first item to swap\");\r\n                    log(area, player, \"press space to cancel\");\r\n                    ui.mode = UIMode.InventorySwapFirst;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.InventoryDrop:\r\n            player.inventory.forEach((item) => {\r\n                if (ev.key === getInventoryChar(player, item)) {\r\n                    dropItem(player, item, area);\r\n                    ui.mode = UIMode.Default;\r\n                }\r\n            });\r\n            switch (ev.key) {\r\n                case \" \":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.InventoryEquip:\r\n            player.inventory.forEach((item) => {\r\n                if (ev.key === getInventoryChar(player, item)) {\r\n                    log(area, player, `${player.name} equips a ${item.name}`);\r\n                    item.equipped = true;\r\n                    ui.mode = UIMode.Default;\r\n                }\r\n            });\r\n            switch (ev.key) {\r\n                case \" \":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.InventoryUnequip:\r\n            player.inventory.forEach((item) => {\r\n                if (ev.key === getInventoryChar(player, item)) {\r\n                    log(area, player, `${player.name} unequips a ${item.name}`);\r\n                    item.equipped = false;\r\n                    ui.mode = UIMode.Default;\r\n                }\r\n            });\r\n            switch (ev.key) {\r\n                case \" \":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.InventorySwapFirst:\r\n            player.inventory.forEach((item, index) => {\r\n                if (ev.key === getInventoryChar(player, item)) {\r\n                    ui.inventorySwapFirst = index;\r\n                    log(area, player, \"select second item to swap\");\r\n                    log(area, player, \"press space to cancel\");\r\n                    ui.mode = UIMode.InventorySwapSecond;\r\n                }\r\n            });\r\n            switch (ev.key) {\r\n                case \" \":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.InventorySwapSecond:\r\n            player.inventory.forEach((item, index) => {\r\n                if (ev.key === getInventoryChar(player, item)) {\r\n                    ui.inventorySwapSecond = index;\r\n                    log(area, player, `${player.name} swaps the ${player.inventory[ui.inventorySwapFirst].name} with the ${player.inventory[ui.inventorySwapSecond].name}`);\r\n                    const t = player.inventory[ui.inventorySwapFirst];\r\n                    player.inventory[ui.inventorySwapFirst] = player.inventory[ui.inventorySwapSecond];\r\n                    player.inventory[ui.inventorySwapSecond] = t;\r\n                    ui.mode = UIMode.Default;\r\n                }\r\n            });\r\n            switch (ev.key) {\r\n                case \" \":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n            }\r\n            break;\r\n        case UIMode.Character:\r\n            switch (ev.key) {\r\n                case \"o\":\r\n                    ui.mode = UIMode.Default;\r\n                    break;\r\n            }\r\n            break;\r\n    }\r\n    switch (ev.key) {\r\n        case \"[\":\r\n            log(area, player, \"game saved\");\r\n            save();\r\n            break;\r\n        case \"]\":\r\n            log(area, player, \"game loaded\");\r\n            load();\r\n            break;\r\n        case \"\\\\\":\r\n            console.log(game);\r\n            break;\r\n        case \"-\":\r\n            game.fontSize--;\r\n            break;\r\n        case \"=\":\r\n            game.fontSize++;\r\n            break;\r\n        case \"1\":\r\n            game.godMode = !game.godMode;\r\n            break;\r\n        case \"2\":\r\n            game.stopTime = !game.stopTime;\r\n            break;\r\n        case \"3\":\r\n            game.ignoreFov = !game.ignoreFov;\r\n            break;\r\n    }\r\n    draw();\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/input.ts\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}